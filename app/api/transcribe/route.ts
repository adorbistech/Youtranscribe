import { type NextRequest, NextResponse } from "next/server"

interface TranscriptionRequest {
  videoId: string
  language?: string
  service?: "whisper" | "google" | "auto"
}

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as TranscriptionRequest
    const { videoId, language = "en", service = "auto" } = body

    console.log("=== TRANSCRIPTION REQUEST ===")
    console.log("Video ID:", videoId)
    console.log("Language:", language)
    console.log("Service:", service)

    if (!videoId) {
      return NextResponse.json({ error: "Video ID is required" }, { status: 400 })
    }

    // Try multiple extraction methods
    const subtitles = await extractSubtitlesWithMultipleMethods(videoId, language)

    if (subtitles && subtitles.length > 50) {
      console.log("‚úÖ SUCCESS: Subtitles extracted successfully")
      console.log("Length:", subtitles.length)
      console.log("Preview:", subtitles.substring(0, 200) + "...")

      // Save to history
      await saveTranscription(videoId, subtitles, "youtube-cc", language)

      return NextResponse.json({
        transcript: subtitles,
        language,
        service: "youtube-cc",
        timestamp: new Date().toISOString(),
        success: true,
      })
    }

    console.log("‚ùå FAILED: No subtitles found after trying all methods")

    return NextResponse.json(
      {
        error:
          "No subtitles found for this video. This video either doesn't have captions or they're not publicly available.",
        suggestion: "Try a different video with captions, or the creator needs to add subtitles to their video.",
        videoId,
        debug: "All extraction methods failed",
      },
      { status: 404 },
    )
  } catch (error) {
    console.error("‚ùå TRANSCRIPTION ERROR:", error)
    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : "Failed to process video",
        details: error instanceof Error ? error.stack : "Unknown error",
      },
      { status: 500 },
    )
  }
}

async function extractSubtitlesWithMultipleMethods(videoId: string, preferredLanguage: string): Promise<string | null> {
  console.log("\n=== STARTING SUBTITLE EXTRACTION ===")
  console.log("Video ID:", videoId)
  console.log("Preferred Language:", preferredLanguage)

  // Method 1: Try YouTube's timedtext API with various formats
  console.log("\nüîç METHOD 1: Direct timedtext API")
  const directResult = await tryDirectTimedTextAPI(videoId, preferredLanguage)
  if (directResult) {
    console.log("‚úÖ Method 1 SUCCESS")
    return directResult
  }

  // Method 2: Extract from video page HTML
  console.log("\nüîç METHOD 2: Video page extraction")
  const pageResult = await tryVideoPageExtraction(videoId, preferredLanguage)
  if (pageResult) {
    console.log("‚úÖ Method 2 SUCCESS")
    return pageResult
  }

  // Method 3: Try with auto-generated captions
  console.log("\nüîç METHOD 3: Auto-generated captions")
  const autoResult = await tryAutoGeneratedCaptions(videoId, preferredLanguage)
  if (autoResult) {
    console.log("‚úÖ Method 3 SUCCESS")
    return autoResult
  }

  // Method 4: Try alternative endpoints
  console.log("\nüîç METHOD 4: Alternative endpoints")
  const altResult = await tryAlternativeEndpoints(videoId, preferredLanguage)
  if (altResult) {
    console.log("‚úÖ Method 4 SUCCESS")
    return altResult
  }

  console.log("‚ùå ALL METHODS FAILED")
  return null
}

async function tryDirectTimedTextAPI(videoId: string, language: string): Promise<string | null> {
  const formats = ["srv3", "vtt", "ttml", "json3"]
  const languages = [language, language.split("-")[0], "en", "en-US"]

  for (const lang of languages) {
    for (const fmt of formats) {
      try {
        const url = `https://www.youtube.com/api/timedtext?lang=${lang}&v=${videoId}&fmt=${fmt}`
        console.log(`Trying: ${url}`)

        const response = await fetch(url, {
          headers: {
            "User-Agent":
              "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            Accept: "text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5",
            "Accept-Language": "en-US,en;q=0.5",
            Referer: "https://www.youtube.com/",
            Origin: "https://www.youtube.com",
          },
        })

        if (response.ok) {
          const text = await response.text()
          console.log(`Response length: ${text.length}`)
          console.log(`Response preview: ${text.substring(0, 200)}`)

          if (text && text.length > 100) {
            const parsed = parseSubtitleContent(text, fmt)
            if (parsed && parsed.length > 50) {
              console.log(`‚úÖ Success with ${lang}/${fmt}`)
              return parsed
            }
          }
        } else {
          console.log(`‚ùå HTTP ${response.status} for ${lang}/${fmt}`)
        }
      } catch (error) {
        console.log(`‚ùå Error with ${lang}/${fmt}:`, error.message)
      }
    }
  }

  return null
}

async function tryVideoPageExtraction(videoId: string, language: string): Promise<string | null> {
  try {
    const pageUrl = `https://www.youtube.com/watch?v=${videoId}`
    console.log(`Fetching: ${pageUrl}`)

    const response = await fetch(pageUrl, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.9",
        "Cache-Control": "no-cache",
      },
    })

    if (!response.ok) {
      console.log(`‚ùå Failed to fetch page: ${response.status}`)
      return null
    }

    const html = await response.text()
    console.log(`Page HTML length: ${html.length}`)

    // Look for player response data
    const patterns = [
      /var ytInitialPlayerResponse = ({.*?});/,
      /"playerResponse":"(.*?)","playerAds"/,
      /ytInitialPlayerResponse\s*=\s*({.*?});/,
    ]

    for (const pattern of patterns) {
      const match = html.match(pattern)
      if (match) {
        try {
          let playerData = match[1]

          // Handle escaped JSON
          if (match[0].includes('"playerResponse"')) {
            playerData = playerData.replace(/\\"/g, '"').replace(/\\\\/g, "\\")
          }

          const playerResponse = JSON.parse(playerData)
          console.log("Found player response data")

          if (playerResponse.captions?.playerCaptionsTracklistRenderer?.captionTracks) {
            const tracks = playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks
            console.log(`Found ${tracks.length} caption tracks:`)

            tracks.forEach((track, i) => {
              console.log(`Track ${i}: ${track.languageCode} - ${track.name?.simpleText || "No name"}`)
            })

            // Find best matching track
            const selectedTrack =
              tracks.find((track: any) => track.languageCode === language) ||
              tracks.find((track: any) => track.languageCode?.startsWith(language.split("-")[0])) ||
              tracks.find((track: any) => track.languageCode === "en" || track.languageCode?.startsWith("en")) ||
              tracks[0]

            if (selectedTrack?.baseUrl) {
              console.log(`Selected track: ${selectedTrack.languageCode}`)
              console.log(`Base URL: ${selectedTrack.baseUrl}`)

              const subtitleResponse = await fetch(selectedTrack.baseUrl)
              if (subtitleResponse.ok) {
                const xmlData = await subtitleResponse.text()
                const parsed = parseSubtitleContent(xmlData, "xml")
                if (parsed && parsed.length > 50) {
                  return parsed
                }
              }
            }
          }
        } catch (parseError) {
          console.log("‚ùå Error parsing player response:", parseError.message)
          continue
        }
      }
    }

    return null
  } catch (error) {
    console.log("‚ùå Video page extraction error:", error.message)
    return null
  }
}

async function tryAutoGeneratedCaptions(videoId: string, language: string): Promise<string | null> {
  const autoLanguages = [`a.${language}`, `a.${language.split("-")[0]}`, "a.en"]

  for (const lang of autoLanguages) {
    try {
      const url = `https://www.youtube.com/api/timedtext?lang=${lang}&v=${videoId}&fmt=srv3`
      console.log(`Trying auto-generated: ${url}`)

      const response = await fetch(url, {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          Referer: "https://www.youtube.com/",
        },
      })

      if (response.ok) {
        const text = await response.text()
        if (text && text.length > 100) {
          const parsed = parseSubtitleContent(text, "srv3")
          if (parsed && parsed.length > 50) {
            console.log(`‚úÖ Auto-generated success: ${lang}`)
            return parsed
          }
        }
      }
    } catch (error) {
      console.log(`‚ùå Auto-generated error for ${lang}:`, error.message)
    }
  }

  return null
}

async function tryAlternativeEndpoints(videoId: string, language: string): Promise<string | null> {
  const endpoints = [
    `https://video.google.com/timedtext?lang=${language}&v=${videoId}`,
    `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${language}&name=`,
    `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${language}&tlang=${language}`,
  ]

  for (const endpoint of endpoints) {
    try {
      console.log(`Trying alternative: ${endpoint}`)
      const response = await fetch(endpoint, {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          Referer: "https://www.youtube.com/",
        },
      })

      if (response.ok) {
        const text = await response.text()
        if (text && text.length > 100) {
          const parsed = parseSubtitleContent(text, "xml")
          if (parsed && parsed.length > 50) {
            console.log("‚úÖ Alternative endpoint success")
            return parsed
          }
        }
      }
    } catch (error) {
      console.log(`‚ùå Alternative endpoint error:`, error.message)
    }
  }

  return null
}

function parseSubtitleContent(content: string, format: string): string {
  try {
    console.log(`\nüìù PARSING CONTENT (${format})`)
    console.log(`Content length: ${content.length}`)
    console.log(`Content preview: ${content.substring(0, 300)}`)

    // Handle different formats
    if (format === "vtt" || content.includes("WEBVTT")) {
      return parseWebVTT(content)
    } else if (format === "json3" || content.startsWith("{")) {
      return parseJSON3(content)
    } else if (format === "srv3" || content.includes("<transcript>")) {
      return parseSRV3(content)
    } else {
      return parseXML(content)
    }
  } catch (error) {
    console.error("‚ùå Parse error:", error)
    return ""
  }
}

function parseWebVTT(content: string): string {
  const lines = content.split("\n")
  const textLines = lines.filter(
    (line) =>
      line.trim() &&
      !line.includes("WEBVTT") &&
      !line.includes("-->") &&
      !line.match(/^\d+$/) &&
      !line.match(/^\d{2}:\d{2}:\d{2}/) &&
      !line.includes("NOTE") &&
      !line.includes("STYLE") &&
      !line.includes("Kind:") &&
      !line.includes("Language:"),
  )

  const result = textLines.join(" ").replace(/\s+/g, " ").trim()
  console.log(`WebVTT parsed length: ${result.length}`)
  return result
}

function parseJSON3(content: string): string {
  try {
    const data = JSON.parse(content)
    const events = data.events || []
    const texts = events
      .filter((event: any) => event.segs)
      .flatMap((event: any) => event.segs)
      .filter((seg: any) => seg.utf8)
      .map((seg: any) => seg.utf8.trim())
      .filter((text: string) => text.length > 0)

    const result = texts.join(" ").replace(/\s+/g, " ").trim()
    console.log(`JSON3 parsed length: ${result.length}`)
    return result
  } catch (error) {
    console.log("‚ùå JSON3 parse error:", error)
    return ""
  }
}

function parseSRV3(content: string): string {
  const textRegex = /<text[^>]*>(.*?)<\/text>/g
  const matches = []
  let match

  while ((match = textRegex.exec(content)) !== null) {
    const text = match[1]
      .replace(/&amp;/g, "&")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&apos;/g, "'")
      .replace(/<[^>]*>/g, "")
      .replace(/\s+/g, " ")
      .trim()

    if (text && text.length > 2) {
      matches.push(text)
    }
  }

  const result = matches.join(" ").trim()
  console.log(`SRV3 parsed length: ${result.length}`)
  return result
}

function parseXML(content: string): string {
  const patterns = [/<text[^>]*>(.*?)<\/text>/g, /<p[^>]*>(.*?)<\/p>/g, /<span[^>]*>(.*?)<\/span>/g]

  for (const pattern of patterns) {
    const matches = []
    let match

    while ((match = pattern.exec(content)) !== null) {
      const text = match[1]
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&apos;/g, "'")
        .replace(/<[^>]*>/g, "")
        .replace(/\s+/g, " ")
        .trim()

      if (text && text.length > 2) {
        matches.push(text)
      }
    }

    if (matches.length > 0) {
      const result = matches.join(" ").trim()
      console.log(`XML parsed length: ${result.length}`)
      return result
    }
  }

  return ""
}

async function saveTranscription(videoId: string, transcript: string, service: string, language: string) {
  console.log("üíæ Saving transcription:", {
    videoId,
    service,
    language,
    length: transcript.length,
  })
}
